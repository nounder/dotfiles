#!/usr/bin/env bash

# Benchmark JSON operations in bash, oil, and nu
# Usage: json-bench [iterations]

set -euo pipefail

ITERATIONS="${1:-30}"
TMPDIR=$(mktemp -d)
trap "rm -rf $TMPDIR" EXIT

# Create test JSON file
cat > "$TMPDIR/test.json" << 'EOF'
{
  "users": [
    {"id": 1, "name": "Alice", "email": "alice@example.com", "active": true},
    {"id": 2, "name": "Bob", "email": "bob@example.com", "active": false},
    {"id": 3, "name": "Charlie", "email": "charlie@example.com", "active": true}
  ],
  "metadata": {
    "total": 3,
    "page": 1,
    "per_page": 10
  }
}
EOF

echo "JSON Benchmark: bash vs oil vs nu"
echo "Iterations: $ITERATIONS"
echo ""

measure_time() {
    local start end
    start=$(gdate +%s%N 2>/dev/null || date +%s%N)
    eval "$1" > /dev/null 2>&1
    end=$(gdate +%s%N 2>/dev/null || date +%s%N)
    echo $(( (end - start) / 1000000 ))
}

calc_stats() {
    local name="$1"
    shift
    local times=("$@")
    local sum=0 min=${times[0]} max=${times[0]} count=${#times[@]}

    for t in "${times[@]}"; do
        sum=$((sum + t))
        ((t < min)) && min=$t
        ((t > max)) && max=$t
    done

    local avg=$((sum / count))
    IFS=$'\n' sorted=($(sort -n <<<"${times[*]}")); unset IFS
    local mid=$((count / 2))
    local median=${sorted[mid]}

    printf "  %-8s avg: %3dms  median: %3dms  min: %3dms  max: %3dms\n" "$name" "$avg" "$median" "$min" "$max"
}

run_benchmark() {
    local test_name="$1"
    local bash_cmd="$2"
    local oil_cmd="$3"
    local nu_cmd="$4"

    echo ""
    echo "=== $test_name ==="

    local BASH_TIMES=() OIL_TIMES=() NU_TIMES=()

    for i in $(seq 1 "$ITERATIONS"); do
        t=$(measure_time "$bash_cmd")
        BASH_TIMES+=("$t")
        t=$(measure_time "$oil_cmd")
        OIL_TIMES+=("$t")
        t=$(measure_time "$nu_cmd")
        NU_TIMES+=("$t")
        printf "\r  Progress: %d/%d" "$i" "$ITERATIONS"
    done
    echo ""

    calc_stats "bash+jq" "${BASH_TIMES[@]}"
    calc_stats "oil" "${OIL_TIMES[@]}"
    calc_stats "nu" "${NU_TIMES[@]}"
}

# Check for required tools
for cmd in bash oil nu jq; do
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: $cmd not found"
        exit 1
    fi
done

# Check oil JSON capabilities
echo "Checking oil JSON support..."
if oil -c "json read <<< '{\"a\":1}'" 2>/dev/null; then
    OIL_HAS_JSON=true
    echo "  oil has native JSON support"
else
    OIL_HAS_JSON=false
    echo "  oil will use jq"
fi
echo ""

# Warmup
echo "Warming up..."
bash -c "jq '.users[0].name' $TMPDIR/test.json" > /dev/null 2>&1
oil -c "json read < $TMPDIR/test.json" > /dev/null 2>&1 || true
nu -c "open $TMPDIR/test.json | get users.0.name" > /dev/null 2>&1

# Define commands
JSON="$TMPDIR/test.json"

# READ
run_benchmark "READ: Extract nested value (.users[0].name)" \
    "bash -c \"jq -r '.users[0].name' $JSON\"" \
    "oil -c \"json read < $JSON; = _reply['users'][0]['name']\"" \
    "nu -c 'open $JSON | get users.0.name'"

# PARSE
run_benchmark "PARSE: Count array elements" \
    "bash -c \"jq '.users | length' $JSON\"" \
    "oil -c \"json read < $JSON; = len(_reply['users'])\"" \
    "nu -c 'open $JSON | get users | length'"

# FILTER
run_benchmark "FILTER: Filter active users" \
    "bash -c \"jq '[.users[] | select(.active == true)]' $JSON\"" \
    "oil -c \"json read < $JSON; for u in (_reply['users']) { if (u['active']) { echo \\\$u } }\"" \
    "nu -c 'open $JSON | get users | where active == true'"

# WRITE
run_benchmark "WRITE: Modify and output JSON" \
    "bash -c \"jq '.metadata.total = 99' $JSON > $TMPDIR/out.json\"" \
    "oil -c \"json read < $JSON; setvar _reply['metadata']['total'] = 99; json write (_reply)\" > $TMPDIR/out.json" \
    "nu -c 'open $JSON | update metadata.total 99 | save -f $TMPDIR/out.json'"

# TRANSFORM
run_benchmark "TRANSFORM: Extract emails as list" \
    "bash -c \"jq -r '[.users[].email] | join(\\\",\\\")' $JSON\"" \
    "oil -c \"json read < $JSON; var emails = []; for u in (_reply['users']) { append \\\$emails \\\$[u['email']] }; echo \\\$[','.join(emails)]\"" \
    "nu -c 'open $JSON | get users.email | str join \",\"'"

echo ""
echo "=== Summary ==="
echo "bash+jq: bash spawns jq subprocess for each operation"
echo "oil:     native JSON via 'json read/write' builtins"
echo "nu:      native structured data, JSON is first-class"
